Work
----

Before:     10
2015-01-07: 3
2015-01-25: 4
2015-01-28: 9
2015-02-08: 3 
2015-02-09: 2
2015-02-12: 2
2015-02-16: 4
2015-03-11: 7
2015-03-20: 5
2015-03-26: 8
2015-04-01: 1
2015-04-02: 2.5
2015-04-09: 9
2015-04-20: 2
2015-04-23: 4.5
2015-05-01: 6.5
2015-05-06: 2.5
2015-05-07: 6
2015-05-14: 7
2015-05-21: 5
2015-05-28: 8
subtotal:   111

2015-06-04: 6.5
2015-06-10: 13.5
2015-06-18: 7.5
2015-06-19: 5
2015-06-25: 6.5
2015-06-29: 3
2015-07-01: 3
2015-07-02: 7
2015-07-06: 2.5
2015-07-09: 3
2015-07-13: 5.5
2015-07-16: 5
2015-07-21: 12.5
2015-07-23: 6.5
2015-07-27: 3.5
2015-07-29: 3.5
2015-07-30: 8
2015-08-06: 7
2015-08-13: 6
2015-08-17: 6
2015-08-20: 8
2015-08-24: 1.5
2015-08-27: 4.5
2015-09-01: 4.5
2015-09-02: 3
2015-09-03: 6.5
2015-09-05: 1.5
subtotal:   261.5

2015-09-10: 6
2015-09-11: 7
2015-09-12: 5.5
2015-09-13: 5.5
2015-09-14: 3
2015-09-17: 13
2015-09-21: 1.5
2015-10-09: 4
2015-10-12: 2.5
2015-10-13: 3
2015-10-14: 3
2015-10-15: 10
2015-10-18: 1.5
2015-10-19: 2.5
2015-10-21: 3.0  (approx)
2015-11-18: 6.5
2015-11-19: 7.5
2015-11-26: 9
2015-12-04: 7.5
2015-12-09: 2.5
2015-12-10: 9.5
2015-12-13: 5.5
2015-12-16: 8
2015-12-20: 4
2015-12-21: 0.5
2015-12-22: 3
2015-12-24: 3
2015-12-26: 5
2015-12-27: 5
2015-12-28: 3
2016-01-14: 9.5
2016-01-19: 2
2016-01-21: 7.5
2016-01-25: 3.5
2016-01-26: 1.5
2016-01-27: 7.5
2016-01-28: 1.5
2016-02-03: 6
2016-02-14: 2.5
2016-02-15: 2
2016-02-17: 5
2016-02-22: 3
2016-02-24: 3
2016-02-27: 3
2016-03-03: 5
2016-03-06: 2.5
2016-03-07: 3
2016-03-08: 7
2016-03-09: 2
2016-03-11: 3
2016-03-13: 2.5
2016-03-16: 10
2016-03-21: 5
2016-03-23: 4
2016-03-28: 4
2016-03-30: 2.5
2016-04-03: 3.5
2016-04-10: 3
2016-04-13: 14.5
2016-04-17: 3.5
2016-04-18: 2
2016-04-27: 9
2016-05-11: 10.5
2016-05-15: 4
2016-05-25: 7.5
2016-06-06: 2
2016-06-07: 3
2016-06-08: 8
2016-06-13: 4.5
2016-06-22: 9
2016-07-07: 7
2016-07-19: 4.5
2016-07-20: 7
2016-07-21: 4.5
2016-08-02: 5
2016-08-03: 7
2016-08-08: 3.5
2016-08-14: 3
2016-08-15: 5
2016-08-16: 6.5
2016-08-20: 10
2016-08-28: 3.5
2016-08-30: 5
2016-08-31: 10.5
2016-09-07: 11
2016-09-11: 3
2016-09-12: 3
2016-09-13: 3
2016-09-14: 7
2016-09-15: 4
subtotal: 455.5

2016-10-23: 4.5
2016-10-24: 2.5
2016-10-25: 2
2016-10-26: 11
2016-10-27: 1
2016-11-03: 3
2016-11-06: 2
2016-11-08: 5
2016-11-09: 9.5
2016-11-10: 1
2016-11-17: 2.5
2016-11-18: 4.5
2016-11-19: 14
2016-11-20: 7
2016-11-23: 3
2016-11-27: 6
2016-12-01: 14
2016-12-07: 10 (including some previous evenings)
2016-12-09: 3
2016-12-11: 3
2016-12-11: 5 (desjardins)
2016-12-12: 1 (desjardins)
2016-12-13: 4
2016-12-14: 9 (desjardins)
2016-12-15: 7 (desjardins, c)
2016-12-16: 4 (desjardins, c)


To test
=======

MainModuleVersionWorkspacePlugin
PROJECT_CODE (checkout, release, switchtodynamic)


Mapping groupes in Config...

- batch mode
- building reference graph but with more than one node

Empty elements in XML -> null? or empty string?


- Batch mode.
- Test workspace within workspace
- IsSync (check with Workspace status)
- Creating new branch with setting up remote tracking separately.
- Events (register dummy events just be see when they are triggered).
- NodeInitPlugin/NodeEventListenerDemo

In the first set of tests, the following will not have been tested:
- NewVersionPhase
- NewVersionSemantic
- Complex version mapping (other than adding or removing v-)
  - To be tested with Phase I believe
- Simple version mapping (with the simple class)
- TaskChangeReference
Hotfix new dynamic version.


If checkoutSystem in a workspace directory that is already checked out and not release, error.




To implement soon
=================


Maybe the list of roots should be defined more elegantly with multiple properties instead of a long single line.

Will need to add traces in Git to know where time is spent.



Store mapping in Config... in transient storage so that at least they are reused in one tool exÃ©cution.

At the end of switch should provide a report of what was not touched as these may be module which the user want to clean from workspace.


Specify ReferencePathMatcher's in a file, with boolean logic
Possibility to provide the ReferencePathMatchers in an external file instead or on top of command line.
- GPSII could provide it more conveniently
Support accessing properties in matcher, such as commit attributes and other (Expression language eventually).

Could ServiceLocator be used to get instances of other services, such as ExecContext, ExecContext plugins, Model?

Have an external cache of modules (checkoutSystem)
- Needs to be synchronized
- Not sure since different tools can access different modules in different order. Deadlocks likely.

Parallel checkouts
- Maybe parallel everything managed by RootModuleVersion.... generic job


When referencing and checking out a version, Validate that the artifact version is OK since it was referenced
But do not always validate. Do not validate when checkout in order to create a new version, in particular
Have to think this trough.






To think
========


The fact that when creating a static version all references must be static maybe should be a decision of the SelectStaticVersionPlugin since for phases,
they may not want to impose that references to modules outside of the PIC are static (references to Infra modules for instance).




Multiple versions of a module in workspace. Implications in ScmGitPlugin, mainly in switchVersion.
- Multiple modules with same name also...



Implement information levels maybe (not sure).
Maybe have the notion of importance in userInteractionCallback:
- Info
- Important
and have verbose modes --whisper and --silent (or --quiet?) to select which information is actually displayed
Some tools may produce reports. This information is the actual payload and cant be quieted.
Maybe the list of important actions (those that modify stuff) should be handled with userInteractionCallback?



GPSII has implemented simple variable references in POMs.
The variable can be defined in same POM or in parent, provided it is in same module.
But what if multiple module references use the same variable? When chaning the variable, module modules can be affected, and Dragom is not equiped to react to this.
But at some point they said they were not sure if it was worth implementing. 



Should I implement automatic property references: the value of a property contains ${PROPERTY}, a reference to another property, as in QuickBuild.
This would be transparent to callers.
Would there be an actual language such as OGML, MVEL or Groovy or some other Java expression engine?
Pretty powerful, but maybe not required initially. The syntax should allow cleanly integrating it after (must use ${} for expressions...
  But a simple property name is probably not an expression...

Spring has an EL (Spel) that seems very nice.
But maybe could support property access using ${} syntax, which is typical for property accesses.
And for general expression, when that would be provided, another syntax such as @{}.


  
What if multiple submodules refer to the same external module?
- Multiple references?
- Multiple updates required?
- Should the caller see only one? And all are updated simultaneously?
- Probably not since the versions may be different.
- Maybe in the reference graph path include a description of where the reference is? Maybe only for display purposes.
- Special case: Multiple references to same module within exactly same POM: Maybe not supported since class Pom may have problems locating
  - Then again, maybe not since the same module may not appear maybe within same reference category.
- Also there could be multiple references to different submodules of the same aggregator module.


Credential manager to integrate with outside world
  In ExecContext
  Maybe for Git no need since Git client handles it, but for Jenkins, etc.
  Similar to what was done with SIPL.


It sounds we need to distinguish between different types of dynamic or static versions.
  - Not all static versions are appropriate for release (maybe only a test...)
Likewise will we need to distinguish between different types of dynamic versions
- Project (develop)
- Integration (develop)
- Features
- Bugfix
- Master?
Maybe no need to introduce version types beyond static/dynamic. It is the version creation process that is different.
 



Eclipse tricks
==============

It is easy enough to create a Maven submodule within a module in Eclipse (RC -> Maven -> New maven module), but by default, the resource within the WS will be named after the directory.
- It is better named after the artifactId.
- Easy: Just rename de ressource in project explorer.
- Also, need to rename artifactId after creating submodule since by default, artifactId is the module name (need to add the prefix artifactId of parent)

Installed releng tools plugin, but limited since cannot control the format of the comment (I do not want a javadoc style comment).

Installed CheckStyle plugin (eclipse-cs)



Archived notes (probably not pertinent anymore, but not 100% sure)
==================================================================

search:
- depth-first traversal among modules
- ask the module (plugin?) if it produces this artifact
  - Possible responses: yes, maybe, no
  - If 2 modules say yes, error
  - If one module says yes, return that one
  - With only maybes, cannot conclude here. Must go through the classification nodes since they will impose an order of precedence.

- If no module says yes, it means that maybe the module has not been (dynamically) created, so need to go through the classifications nodes
- depth-first traversal among classification nodes
- ask the classification node if it knows about the artefact
  - Possible responses:
    - yes would not be a possible answer as only modules can say for sure.
    - maybe and here is a list of module paths to try
      - The tries will be similar to the module search above.
      - If one of the modules says yes, it is the one (the first one that says yes)
      - If no module says yes, the first one that says maybe is the one
      - The order is thus important (from most specific to least)
    - no, unless a module already exists that said yes (and it will have been visited above)

When new modules are added dynamically, maybe they would violate the unicity of the mapping from ArtifactGroupId to module?
But this would not be detected.
So they could be a difference in behavior depending on the ordre in which modules are requested.
Unless when a new modules is created, the rootnode (and maybe other node in the patch) must be warned so that they can do some validation?





Not to implement
================

To avoid property name space pollution, maybe a plugin uses the property name,
but before tries a property with as a prefix the plugin class name. This would allow the human configuring the whole thing to
avoid property name clash by scoping properties to specific plugins. But in that case, property reuse among plugin will be harder.
Don't know if that would be useful.

similar to:  
And what if for 2 different processes, the same plugin is used but different parameters are required?
Maybe the parameters (properties) could be keyed with the plugin id. The keyed parameter would have precedence over non-keyed.
In Node, have a getPropertyForPlugin(PluginDef, name)
- Would consider inheritance like getPropertyDefWithInheritance
- Would use the plugin ID in PluginDef to key properties
- Maybe could also allow properties to be visible to certain plugin based on the plugin name? Not sure.
 
*** This does not seem useful. I cannot think of a really pertinent use case for having plugin-specific properties.

Maybe before supporting an expression language engine, support fixed syntax for property references:
- ${PROPERTY}: The value of another property, evaluated in the context of the current object, not the one who has the definition that refers to the property (as in QuickBuild).
- ${parent:PROPERTY}: The value of another property, evaluated in the context of the parent of the current object. Useful for path building.But it would completely work for path building as in the workspace path in QC (${parent:PATH}.${name} defined at top level only)
- ${parent-defined:PROPERTY}: The value of another property, evaluated in the context of the parent of where the definition was taken. Yes, this works for options building with gaps.

*** Already implemented. But the parent-defined stuff is not. Not sure useful.

  Eventually, may be pertinent to have a plugin that can return the last modification time of a module (only the sources files)
This could be compared to the last time the module was built so that rebuild is not required.
That last time a module is built would be stored in the workspace.

*** Don't see a real use for this for now.

Should we handle module fork in development projets? (switch to dynamic version)

*** Defitively not for now.

Model serialisation
  Recognize transient object created on the fly (do not store them?)
  But should the dump be more like QuickBuild?
    - List of this
    - List of that
    - With references in between?
    Maybe JAXB can do this with references?

*** Not for now.

For a reference, what happens if a property is used?
- This IS a problem that could make adoption difficult
- We could say that if a property is used, then this is not a true reference.
  - But in the pom that defines the proprety, how can we recognize this is a version reference??? We can't.
- Dependency management is an alternative that is supported, but I think properties are often used.
- Maybe support it only within a given POM (the property must be defined locally)
- We could argue this is a nice practice anyways since referring to properties defined elsewhere makes management harder
- But then again, global properties can be useful.
- Maybe simply say that Dragom does not support externally defined properties for version reference. Only locally defined.
- But for now, no support for properties in version references.

*** We do not support property references for now (exception ${project.version within an aggregation).





Merge
=====

When the user adds by himself a new reference, it is a commit that may not be excluded because not recognized to be from Dragom
In dest, the reference may be to the same dynamic version as in org
Maybe the reference analysis will spot this (same dynamic version)
  - In such as case it should probably offer to switch to another dynamic version. 

Pull vs push: It seems to me like pull is always the way to go since conflicts can always happen and we must have a local workspace to resolve them.
That is the way all SCM work (merge into local).
Even pull request is merge into local conceptually.
You never push-merge something.
So forget about push.

It is always pull, and we always iterate over remote. But for each ModuleVersion in remote (only known modules), two modes:
- Navigate path in source, but without regard to versions of modules (but considering types of references), in order to find version of module to merge into
  - ModuleVersion in source may not exist. In that case, simply display a message.
    - There is nothing we can do. If there was supposed to be something, it would have been handled by a previous merge.
  - For top-level module, it is as if we had an external reference (root module) to the ModuleVersion, so it always exists. 
  - ModuleVersion must be in user workspace directory. If not, offer to checkout, possibly changing existing version. 
  - When got to the module, apply these rules:
  - Source tag, dest tag
    - Any changes in src not in dest?
      - Yes: Any changes in dest not in source?
        - Yes: Offer to switch dest version to dynamic, and then perform merge with new (dynamic version), and then descend in graph
        - No: Offer to replace source version with that of dest (normally, parent should already be dynamic because of parent first treatment). Should we fail if not the case? **** Need to think about this. If we open the path, we may introduce dynamic versions in parent that could simply have been changed to static
      - No: No merge required.
  - Source branch, dest tag
    - Any changes in src not in dest?
      - Yes: Offer to switch dest version to dynamic, and then perform merge with new (dynamic version), and then descend in graph.
      - No: No merge required.
  - Dest branch
    - Any changes in src not in dest?
      - Yes: Merge with changes, and descend in graph
      - No: No merge required.
- Ask user which version to merge into (or use a default base specified globally, or other strategy)
  - User must select dynamic version
  - Not possible to create a new dynamic version
  - If ever a new version would have needed to be created, it would have been in a reference graph, and the first mode would have been used.
  - ModuleVersion must be in user workspace directory. If not, offer to checkout, possibly switching existing version. 
  - Any changes in src not in dest?
    - Yes: Merge with changes.
    - No: No merge required.

So we start with version management (tag vs branch, and then merge)
Merge excludes commits made by Dragom that relate to version adjustments (of the module itself, of references)

Again:

It is always pull.
Therefore source is remote.
We iterate over source. For each ModuleVersion in source (only known modules).
Two modes: Navigate in dest, Select dynamic version
- Navigate path in dest, but without regard to versions of modules (but considering types of references), in order to find version of module to merge into
  - ModuleVersion in dest may not exist. In that case, simply display a message.
    - There is nothing we can do. If there was supposed to be something, it would have been handled by a previous merge.
  - For top-level module, it is as if we had an external reference (root module) to the ModuleVersion, so it always exists. 
  - ModuleVersion must be in user workspace directory. If not, offer to checkout, possibly changing existing version. 
  - When got to the module, apply these rules:
  - Source tag, dest tag
    - If both Version's equal, no merge required.
    - Verify how source and dest diverge:
      - Starting at this ModuleVersion in source, tranverse the graph
      - For each corresponding ModuleVersion in source that exists (ignore those that do not since if they were important, they would have been considered in the parent verification):
        - Verify how source and dest diverge
        - If source has changes not in dest, record that fact globally
        - If dest has changes not in source, record that fact globally
    - If source and dest equal (not likely since different Version's, but still possible), no merge required. 
    - If only source diverges, replace Version in dest parent with Version in source. Dest parent is necessarily dynamic.
    - If only dest diverges, no merge required and stop descending since we checked deep
    - If both source and dest diverge (fork), cannot merge. Conflict. Stop processing this ModuleVersion.
  - Source branch, dest tag
    - Verify how source and dest diverge (same as above)
    - If source and dest equal (not likely since different Version's, but still possible if the source branch has just been created), no merge required. 
    - If source diverges, offer to switch dest version to dynamic, and goto below (branch, branch)
      - If dest also diverges, issue a warning. This is probably not a problem as the switch-to dynamic version will probably include these changes.
    - If only dest diverges, no merge required and stop descending since we checked deep
  - Dest branch (source tag or branch)
    - Any changes in src not in dest (only this ModuleVersion)
          ????? humm, not sure if only this ModuleVersion. What if changes in children only. No, ok. Would be handled when descending.
      - Yes: Merge with changes, and descend in graph
      - No: No merge required, but continue descending in graph
- Select dynamic version
  - Seems to apply only if source is tag, but in fact, it also makes sense in the general case (source branch), if the user wants to update master for all modules.
    - Humm, no. If source is not tag, it implies that if reference to such dynamic version in source, the branch that would be used in dest should be referenced also and wired to parent. 
  - This mode cannot be inferred since, for instance, when ModuleVersion not found in dest.
  - It is really two modes, two different intents of the user.
  - Ask user which version to merge into (or use a default base specified globally, or other strategy)
    - User must select dynamic version
    - Not possible to create a new dynamic version
    - If ever a new version would have needed to be created, it would have been in a reference graph, and the first mode would have been used.
    - ModuleVersion must be in user workspace directory. If not, offer to checkout, possibly switching existing version.
    - Source must be tag. See above.
    - Do as above for each individual module referenced, only one level deep, including analysing how source and dest graphs diverge 
    - If source and dest equal (not likely since different Version's, but still possible), no merge required. 
    - If only source diverges, replace Version in dest parent with Version in source. Dest parent is necessarily dynamic.
    - If only dest diverges, no merge required and stop descending since we checked deep
    - If both source and dest diverge (fork), cannot merge. Conflict. Stop processing this ModuleVersion.

So we start with version management (tag vs branch, and then merge)
Merge excludes commits made by Dragom that relate to version adjustments (of the module itself, of references)



Command line syntax:

merge
Traverse workspace in the usual way, root module versions and reference graph paths
When a match is found, this is a root destination for a merge
Destination must be dynamic
If a destination is selected and merged in, do not traverse into
Select a source version to merge into destination (may be specified by runtime properties)
 
merge-base <source-module-version>
This tool does not work in the same way as most others
Generally done on an empty workspace
Source version must be static
Traverses the source ModuleVersion reference graph (all static)
For each ModuleVersion merge into user-defined version, without considering children. 


It is ok to consider root and root reference graph path matchers for a system like Portail Caisse since it defines on what applications to work, regardless of the other applications that may be modified at the global level by others.

Next tool: Report
=================

For the version coherence report, maybe have it configurable so that only certain modules are considered.
Dragom cannot really know if a module dependency is compile-type or runtime type. But it can be told.
Work with coherence rules.
One rule:
Given an artifact reference (service implementation), all references to that other artifact (service interface) must have same major and equal-to or inferior minor.
Can this work if interface is a separate module?


Other tool: Module info
=======================

Display module information given
- NodePath
- URL
- GAV
Information:
- All plugins
- All properties
  - Including from parent?



Marketing and Dragom web site (info from FL)
============================================

Use what FranÃ§ois has setup.
  
URL : https://fidooda02.sbin.ca:8080/



IP hosting :  199.19.212.118  (pour le "A Record")
2016-11-13: Ceci est l'IP du serveur de FranÃ§ois. J'ai changÃ© pour GitHub Pages 192.30.252.153.



Lorsque le A Record sera updatÃ© :

site:

https://dragom.org
https://dragom.org/wp-admin



Il resterait juste le setup du SSL Ã  faire.  Je suggÃ¨re y aller direct en https only.


Pour le "look" je recommande d'acheter un child theme sur le framekwork "genesis".

J'ai fait un tri pour toi de thÃ¨me que je crois appropriÃ© pour un blog technique.

http://my.studiopress.com/themes/sixteen-nine/

http://my.studiopress.com/themes/eleven40/

Tu peux p-e penser que c'est cher 100$ mais Ã§Ã¡ vaut la peine.

Sinon, ya toujours themforest mais humm... le framework de dÃ©veloppement ne sera pas "DR approved"

http://themeforest.net/category/wordpress/technology/software



Use Mail Poet in WordPress for mailings
Pass through Amazon SES for SMTP


Dragom articles:

- Who I am
- What in the name
- Origin of the Dragom project
- Application modularization
- Versioning at the repository level
- Versioning at the module level
- Submodules are implementation details
- Source-level reuse vs artifact reuse
- Autonomous modules
  - Not in the sense that they run by themselves
  - In the sense that they describe their build
- What is a module reference graph
  - Vs module dependency graphs
- Shallow and narrow module reference graphs
  - Many large projects are rather monolithic
- Deep and/or wide module reference graphs
  - Software developped in house by large organizations
- The problems introduced by deep and/or wide module reference graphs
- Dragom is here to help
- By raising the basic module-level version management features to module reference graphs
- Creating a branch in a module reference graph
- Creating CI jobs for a module reference graph
- Merging a branch of a module reference graph into another branch
- Releasing a module reference graph
- Analysing the modules versions in a module reference graph

Documentation:

Conventions for properties
- Model properties: UPPER_CASE_WITH_UNDERSCORES

- Runtime Properties in ExecContext: runtime-property.Domain1.app-a.UPPER_CASE_WITH_UNDERSCORES 
- Runtime Properties: prefix: lower-case-with-dashes
- Runtime Properties in system properties: com.azyva.dragom.runtime-properties.Domain1.app-a.UPPER_CASE_WITH_UNDERSCORES

- TaskParams: ClassName.propertyName.
- The 2 types of plugin implementations (factory and constructor)
- Config vs Model.



Blog articles that would become documents articles
1. Need a teaser



Demo
====
  
- Checkout tag (production), recurse
dragom-checkout --workspace-path=workspace --artifact-refs= Domain1/app-a:S/1.2

- Prepare projet to work on this and this module
dragom-switch-to-dynamic-version --workspace-path=workspace --module-reference-graph-path=src#Framework/parent-model Domain1/app-a:S/1.2

- Other developer checkout all branches at once
dragom-checkout --workspace-path=workspace2 --artifact-refs=::.*-SNAPSHOT Domain1/app-a:D/develop-123d56

- Make modification to a module
In parent-model/pom.xml, add a property, commit and push

- Add a module
dragom-switch-to-dynamic-version --workspace-path=workspace --module-reference-graph-path=src#AppFramework/app-framework Domain1/app-a:D/develop-123d56

- Make modification to new module
In app-framework/pom.xml, add a property, commit and push

- Release
dragom-create-static-version --workspace-path=workspace Domain1/app-a:D/develop-123d56

- Checkout release
dragom-checkout --workspace-path=workspace3 --artifact-refs= Domain1/app-a:S/2015-08-01

- Reprepare for modification to a module
dragom-switch-to-dynamic-version --workspace-path=workspace --module-reference-graph-path=src#AppFramework/app-framework Domain1/app-a:D/develop-123d56

- Make modification to one module
In app-framework/pom.xml, add another property, commit and push

- Re-release
dragom-create-static-version --workspace-path=workspace Domain1/app-a:D/develop-123d56

- Checkout release
dragom-checkout --workspace-path=workspace3 --artifact-refs= Domain1/app-a:S/2015-08-01


for i in `ls` ; do echo $i ; git -C $i status ; echo === ; done



 
- Other developper works on a feature branch for a specific module, but that requires opening the path
- Other developer requests another module in project work space 

Talk about whats to come:
- Notion of roots
- Merge feature branche into project branch
- Produce a report of what modules have been modified (are on branches)
- Use that report output to create release branches
- Merge project into release branch
- Do this as soon as date is known to promote continuous integration between projects
- Or keep projects separate and regularly merge each project changes in release branch, in case a projet removes itself
- Each project can symetrically merge into release
- Perform the release by walking the graph
- Rebuild all?
- Version coherence

Older notes (DÃ©monstration)
- Mapping de version
- Mapping de artifactGroupId Ã  ModuleClassificationPath et vers SCM URL.
- Subversion vs Git (checkout hybride).
- Exceptions au niveau des groupId et artifactId.
- Source vs artifact references
In the demo, should probably illustrate dependency management.






Formation
- 25 ans expÃ©rience en industrie
- 10 ans gestion des configurations logicielles (SCM) et ingÃ©nierie des publications des logiciels (release engineering)
  - Gestion des source
  - StratÃ©gie de versionnement, branches et Ã©tiquettes
  - IntÃ©gration continue
  - Automatisation des tests
  - Automatisation des dÃ©ploiements
  - Publications
  - SystÃ¨mes d'envergures modulaires
  - Plusieurs Ã©quipes de dÃ©veloppement distinctes
  - Plusieurs efforts de dÃ©veloppement en parallÃ¨l
- ExpÃ©rience en formation

- Mise en place d'une plateforme d'intÃ©gration continue avec Jenkins, Artifactory, Git
- Utilisation de Git

GeneviÃ¨ve Brouillette
396-8800 7265


David Raymond
AppelÃ© au 514 396-8830 rÃ©fÃ©rÃ© Ã  vous
Confusion lors appel prÃ©cÃ©dent
  - BoÃ®te vocale

Sujets:
- Pour (grandes) entreprises
- Gestion du code source des application
- StratÃ©gie de versionnement
- IntÃ©gration continue
- Livraison continue
- Automatisation des dÃ©ploiements
- DevOps
- Mise en place d'une plateforme d'intÃ©gration/livraison continue
  - Jenkins (Enterprise)
  - Git
  - Gestionnaire d'artefacts
- Maven  
- RÃ©utilisation binaire




     ___________
    |  /|\  |  /|\
    |/__|__\|/  |__\
   / \  |    \  |  /|
 /_____\|______\|/__|
|\  |  /
|__\|/

       _________________
      |    /|\    |    /|\
      |  /  |  \  |  /  |  \
      |/____|____\|/    |____\
     / \    |      \    |    /|
   /     \  |        \  |  /  |
 /_________\|__________\|/____|
|\    |    /
|  \  |  /
|____\|/


         _______________________
        |      /|\      |      /|\
        |    /  |  \    |    /  |  \
        |  /    |    \  |  /    |    \
        |/______|______\|/      |______\
       / \      |        \      |      /|
     /     \    |          \    |    /  |
   /         \  |            \  |  /    |
 /_____________\|______________\|/______|
|\      |      /     ___    ___
|  \    |    /      /   \  /   \ |\    /|
|    \  |  /   _   |      |     || \  / |
|______\|/    / \  |   __ |     ||  \/  |
 ___   ___   |   | |  |  ||     ||      |
|   \ |   \ |_____| \___/  \___/ |      |
|    \|    ||     |
|    ||___/ |     |
|    /|   \
|___/ |    |



         _______________________
        |      /|\      |      /|\
        |    /  |  \    |    /  |  \
        |  /    |    \  |  /    |    \
        |/______|______\|/      |______\
       / \      |        \      |      /|
     /     \    |          \    |    /  |
   /         \  |            \  |  /    |
 /_____________\|______________\|/______|
|\      |      /
|  \    |    / 
|    \  |  /
|______\|/
 ___   ___     _     ___    ___
|   \ |   \   / \   /   \  /   \ |\    /|
|    \|    | |   | |      |     || \  / |
|    ||___/ |_____||   __ |     ||  \/  |
|    /|   \ |     ||  |  ||     ||      |
|___/ |    ||     | \___/  \___/ |      |


     ___________
    |  /|\  |  /|\
    |/__|__\|/  |__\
   / \  |    \  |  /|
 /_____\|______\|/__|
|\  |  /
|__\|/



 __     _____________________________________________________
|  /|\    ___________________________________________________
|/__|  \____   ____               ___       ___             
 \  |  /|\  | |    \     /\      /   \     /   \   |\      /|
   \|/__|__\| |     |   /  \    /     \   /     \  | \    / |
    |   |  /| |     |  /    \  |         |       | |  \  /  |
    |   |/__| |____/  |______| |     __  |       | |   \/   |
    |  / \  | |    \  |      | |    |  | |       | |        |
    |/_____\| |     | |      | |       | |       | |        |
    |\  |  /  |     | |      |  \     /   \     /  |        |
    |__\|/    |     | |      |   \___/     \___/   |        |


 __      ____________________________________________________
|    \     __________________________________________________
|      \____   ____               ___       ___             
 \          | |    \     /\      /   \     /   \   |\      /|
   \        | |     |   /  \    /     \   /     \  | \    / |
    |       | |     |  /    \  |         |       | |  \  /  |
    |       | |____/  |______| |     __  |       | |   \/   |
    |       | |    \  |      | |    |  | |       | |        |
    |       | |     | |      | |       | |       | |        |
    |      /  |     | |      |  \     /   \     /  |        |
    |___ /    |     | |      |   \___/     \___/   |        |



 ___     ____________________________________________________
|    \     __________________________________________________
|      \____   ____               ___       ___             
 \     /    | |    \     /\      /   \     /   \   |\      /|
   \ /      | |     |   /  \    /     \   /     \  | \    / |
    |       | |     |  /    \  |         |       | |  \  /  |
    |       | |____/  |______| |     __  |       | |   \/   |
    |       | |    \  |      | |    |  | |       | |        |
    |       | |     | |      | |       | |       | |        |
    |      /  |     | |      |  \     /   \     /  |        |
    |___ /    |     | |      |   \___/     \___/   |        |




 ___     ____________________________________________________
|   |\     __________________________________________________
|   |  \____   ____               ___       ___             
 \  |    \  | |    \     /\      /   \     /   \   |\      /|
   \|      \| |     |   /  \    /     \   /     \  | \    / |
    |      /| |     |  /    \  |         |       | |  \  /  |
    |    /  | |____/  |______| |     __  |       | |   \/   |
    |  /    | |    \  |      | |    |  | |       | |        |
    |/      | |     | |      | |       | |       | |        |
    |      /  |     | |      |  \     /   \     /  |        |
    |____/    |     | |      |   \___/     \___/   |        |


 ___     ____________________________________________________
|   |\     __________________________________________________
|   |  \____   ____               ___       ___             
 \  |       | |    \     /\      /   \     /   \   |\      /|
   \|       | |     |   /  \    /     \   /     \  | \    / |
    |       | |     |  /    \  |         |       | |  \  /  |
    |       | |____/  |______| |     __  |       | |   \/   |
    |       | |    \  |      | |    |  | |       | |        |
    |       | |     | |      | |       | |       | |        |
    |      /  |     | |      |  \     /   \     /  |        |
    |____/    |     | |      |   \___/     \___/   |        |


















How to create XML from DB:
- XmlClassificationNodeConfig implements ClassificationNodeConfig for integration with Node, etc.
- But Xml... also provides methodes not in any interface to set values, add children, etc.
- So simply take the Config from DB classes and recreate the classes from the Xml... set
- And marshall.
 -Maybe XmlConfig could have a constructor taking a Config and could recreate everything with Xml... classes.
- Makes sense

Maybe the reverse could be true also:
- DbConfig could have a constructor that takes a Config and recreates everything using Db... classes.
- Backup/restore fonctionnality!!!




The notion of being mutable or not (indMutable) is local to each class (Model, Node, etc.)
- Maybe this does not make sense. Can we have a mutable Node within a non-mutable Model?
- Not sure what would be cleaner.


Maybe GitScmPlugin can convert _ in version to / and vice-versa?
Version cannot contain / and this is probably correct.
But it would be convenient to exploit the fact that Git can have / in versions (contrary to many other tools).
Maybe this mapping can be configurable.


When workspace is cleaned, the main workspace directories maintained by git plugin are not removed from exec.properties
- This may or may not be a problem. Probably worth investigating.



Maybe make the various Y, N, Yes all, etc. responses more coherent (sometimes Y means Yes always, other times it is A).



In Release, no switch is performed. But the root ModuleVersion is changed. This may seem inconsistent
But deeper in the graph if a ModuleVersion is released and the parent points to released version, it is the same thing:
  We leave the dynamic version but the parent now refers to static released version
Should we switch everything to the static release version? Probably not since Eclipse would have to switch
So if we do not switch, we keep dynamic, but the root should be symetrical with parent reference. 



CD:
When releasing a ModuleVersion, is there a difference between the ModuleVersion itself and its references?
When release a MV, the references must be released, but nothing says we must release them.
Maybe a mode would just mean ensure they are released and select a release version.

But would it simply be a matter of using a different SelectStaticVersionPlugin for the references?
Maybe can specify a given SelectStaticVeresionPlugin for the specific Module (runtime properties) and have a global one that applies to all other modules.
- Makes sense!

So it is solely the responsibility of the ***SelectStaticVersionPlugin to manage the mapping from dynamic version to corresponding static.

Would that behavior be useful elsewhere?

Like a plugin that returns the base static version to scan for the most recent one.
Would the inverse mapping be useful? (given a static, which dynamic drives the various releases)













Documentation
=============

Dragom is extensible and CONFIGURABLE.

Definitions
- Reference graph
- Independently versioned modules
- Artifact-based development

JAVADOC
- Have a _site/javadoc folder with keep_files (it works)
- Have a script which extracts javadoc jar from Maven repo

For the current snapshot, invite to go to GitHub.
Have a current release
Have a current stable

Have a link to current javadoc

For each release:
- javadoc
release notes
downlaods
Maven coordinates

What Dragom is not?
- Not a Jenkins or Maven plugin (maybe eventually)

Have  story with graphics

Dragom does not come for free. It requires planning, configuration and possibly adjustments to how modules are laid out and built.





Menu:
Overview (-> What is Dragom?)
Getting started (-> Resources/Getting started)
Download (-> Distribution/Download most recent)
Documentation (-> Resources/Documentation, jump to other product)
Javadoc
- dragom-api (most recent)
- dragom-core (most recent)
- dragom-cli-tools (most recent)
Support (-> Resources/Support)

Overview
  What is Dragom?
  Why Dragom (time to tell a story)
  Dragom in action
  What Dragom is not
  History
  Who is behind Dragom?

Distribution
  Dragom modules
  Git repositories
  Dependencies
  Semantic versioning
  GPG signing
  - Key id 0x0F3E7D121FFBD0C2
  - https://sks-keyservers.net
  Download current
  - Maven coordinates of current
  - Links to modules of current
  - Hashes, GPG signature
  - For each module
  Download stable
  - Maven coordinates of stable
  - Links to modules of stable
  - Hashes, GPG signature
  - For each module
  dragom-api releases
  - List of all releases
  - Pointer to most recent (first one)
  - Pointer to stable
  - For each release, links, hashes, md5, gpg signatures 
  dragom-core releases
  - Same
  dragom-cli-tools releases
  - Same

Resources
  Getting started
  - Tutorial with test file-based Git repos
  Documentation -> jump to other "product"
  Javadoc
  - Current
    - dragom-api
    - dragom-core
    - dragrom-cli-tools
  - Stable
    - dragom-api
    - dragom-core
    - dragrom-cli-tools
  Support
  - Stack Overflow
  - GitHub issues (link to dragom-site issues)
  - email
